---
layout: post
title: Sock matching engine
date: 2011-05-21 14:17:07.000000000 +12:00
categories:
- Programming
- Reflections
tags:
- socks
status: publish
type: post
published: true
meta:
  _edit_last: '14086420'
  tagazine-media: a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";s:1:"0";s:6:"author";s:8:"14086420";s:7:"blog_id";s:8:"19263352";s:9:"mod_stamp";s:19:"2011-05-21
    02:22:04";}
  _wpas_skip_yup: '1'
  _wpas_skip_ms: '1'
  _wpas_skip_linkedin: '1'
  _wpas_skip_yahoo: '1'
author: 
---
<p style="text-align:justify;">During a wholly uncharacteristic bout of clothes tidying, I realised that sock matching was essentially the same problem as <a title="Price-time matching&nbsp;engine" href="http://ejrh.wordpress.com/2011/04/21/price-time-matching-engine/">limit matching</a>.<br />
<!--more--></p>
<p style="text-align:justify;">Incoming socks are matched against a queue of existing socks; if there are no matches they are added to the queue.&nbsp; When a pair is matched, they are both removed.&nbsp; Additionally, occasionally someone may say, "Hey Edmund... have you seen any of my expensive black dress socks around?", at which point efficient removal of a sock from the queue is required.</p>
<p style="text-align:justify;">The major difference is that socks aren't matched using a simple relational operator &lt;.&nbsp; Strictly speaking they are matched by the equality operator =.&nbsp; In the case of <a title="Chirality at Wikipedia" href="http://en.wikipedia.org/wiki/Chirality">chiral socks</a> (where the left and right socks in a pair are different), they would be matched on a pair-wise operator (=,!=) where each sock is represented by a tuple of (type, chirality).&nbsp; In practice, it's often hard to tell whether two socks are similar enough to form a pair.&nbsp; We could use an approximate matching operator ~.&nbsp; But you can imagine a trio of socks x ~ y ~ z with x !~ z.&nbsp; The present <a title="Greedy algorithm at Wikipedia" href="http://en.wikipedia.org/wiki/Greedy_algorithm">greedy algorithm</a> from the price-time matching engine could lead to suboptimal matches for socks, with a pair of unmatched socks remaining because their partners have eloped earlier in the process.</p>
<p style="text-align:justify;">Looking for optimal matches rather than simple matches almost certainly means using a backtracking or <a title="Dynamic programming at Wikipedia" href="http://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a> algorithm, not a greedy one.&nbsp; I'll restrict myself to describing equality matching.&nbsp; The consequence of this is that the bidirectional queue structure (implemented with skip lists) from the price-time engine isn't necessary.&nbsp; A hash table does the trick: if two socks hash to the same bucket, then check if they match and remove them both.</p>
<p style="text-align:justify;">The other major difference between efficient sock matching and limit matching is the difference in scale.&nbsp; The price-time matching problem has a specified maximum of 65536 outstanding limits in play at any time.&nbsp; But there seems to be no limit to the number of singular socks generated by my laundry...</p>
