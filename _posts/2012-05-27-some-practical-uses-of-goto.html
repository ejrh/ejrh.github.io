---
layout: post
title: Some practical uses of goto
date: 2012-05-27 15:50:45.000000000 +12:00
categories:
- Programming
tags:
- c
- goto
status: publish
type: post
published: true
meta:
  _edit_last: '14086420'
  _wpas_done_linkedin: '1'
  tagazine-media: a:7:{s:7:"primary";s:0:"";s:6:"images";a:1:{s:88:"http://upload.wikimedia.org/wikipedia/en/math/5/a/6/5a63b2b74c2c29a3f6f729eda8f610d1.png";a:6:{s:8:"file_url";s:88:"http://upload.wikimedia.org/wikipedia/en/math/5/a/6/5a63b2b74c2c29a3f6f729eda8f610d1.png";s:5:"width";s:3:"312";s:6:"height";s:2:"47";s:4:"type";s:5:"image";s:4:"area";s:5:"14664";s:9:"file_path";s:0:"";}}s:6:"videos";a:0:{}s:11:"image_count";s:1:"1";s:6:"author";s:8:"14086420";s:7:"blog_id";s:8:"19263352";s:9:"mod_stamp";s:19:"2012-05-27
    03:50:45";}
  _wpas_skip_yahoo: '1'
author: 
---
<p style="text-align:justify;">A few days ago there was another <a title="Knuth: Structured programming with GOTO (1974)" href="http://www.reddit.com/r/programming/comments/ttp55/knuth_structured_programming_with_goto_1974/">submission on Reddit</a> on the evils of goto. The flow control primitive "goto" is "<a title="Considered harmful at Wikipedia" href="http://en.wikipedia.org/wiki/Considered_harmful">considered harmful</a>" (the phrase was coined by the editor of the journal in which Dijkstra's famous letter was published).<br />
<!--more--></p>
<p style="text-align:justify;">"Considered harmful" has become a meme in the programming community. So has the simplistic tenet that goto should never, ever be used, culminating in other memes such as <a title="GOTO at XKCD" href="http://xkcd.com/292/">this one</a>. It's not in itself funny, but it does illustrate the schooled aversion that modern programmers have to goto. (The cartoon comments on the attitude, rather than intentionally enforces it. But it still provides ammunition to those who say absolutely that goto should not exist.)</p>
<h2>The problems with goto</h2>
<p style="text-align:justify;">Goto is a low-level primitive. At the assembly language level, programs are sequences of instructions, normally executed consecutively. There are occasional branch points where, depending in the result of a computation, the next instruction to be executed may optionally be one located elsewhere in the sequence, where it is identified by a label. And there are gotos, which unconditionally continue execution from a labelled instruction. At this level, gotos are inevitable, and harmless, because the code should be generated by compilers from higher-level programs.</p>
<p style="text-align:justify;">But early "higher-level" languages used goto, too. There were two major problems with this. It lead to progams that were hard to read. The result was called "spaghetti code", because the flow of control weaved all through the program, and each strand had to be individually followed by the reader for them to have any understanding of what the program was doing.</p>
<p style="text-align:justify;">The other objection is more theoretical. Ideally, the correctness of a program should be provable (and actively proved by the programmer). This is still a tricky problem, and in practice most programs are not proved correct.</p>
<p style="text-align:justify;"><a title="Structured programming at Wikipedia" href="http://en.wikipedia.org/wiki/Structured_programming"> Structured programs</a> are composed from smaller programs. If the correctness of smaller programs can be proved, and we can have rules for analysing a compound program in terms of its parts, then we should be able to prove its correctness. So, for instance, Tony Hoare's <a title="Hoare logic at Wikipedia" href="http://en.wikipedia.org/wiki/Hoare_logic">logic for program correctness</a> has inference rules like the following:</p>
<p style="text-align:justify;"><img class="alignnone" src="assets/5a63b2b74c2c29a3f6f729eda8f610d1.png" alt="" width="312" height="47" /></p>
<p style="text-align:justify;">Which essentially says, if <em>P</em> holds true before and after the execution of <code><em>S</em></code> (and <em>B</em> also holds true before <em>S</em>), then <em>P</em> will hold true before and after the execution of <code>while <em>B</em> do <em>S</em></code>. The programmer's job is to define <em>P</em> as a useful invariant which can be used to prove that the loop performs a correct computation.</p>
<p style="text-align:justify;">In structured programming, the entire program is composed of these structures; and, with suitable invariants, its correctness can be proved.</p>
<p style="text-align:justify;">What about goto? The problem with goto is that there is no longer an obvious recursive structure. It is harder to find self-contained subprograms whose correctness can be proved, and hence harder to prove the correctness of the whole program. The Knuth paper from the Reddit submission contains logic rules for gotos and labels; but the potential for overlapping code between gotos and their targets is still a problem.</p>
<h2>How goto is used in practice</h2>
<p style="text-align:justify;">Although I like to think I use goto in sensible ways, I thought I should conduct a survey of my codebase. The keyword goto occurs in 24 places in my C code, in the projects <a title="Massively parallel fractals" href="http://ejrh.wordpress.com/2012/01/04/massively-parallel-fractals/">fractal</a>, <a title="Compiler" href="http://ejrh.wordpress.com/2012/03/01/compiler/">compiler</a>, <a title="Writing a file system" href="http://ejrh.wordpress.com/2011/07/29/writing-a-file-system/">fs</a>, and svnindex. There are three ways in which it is used.</p>
<h3>Cleaning up</h3>
<p style="text-align:justify;">The first is a jump to cleanup code before exiting a function, of this form:</p>
<p>[sourcecode language="c"]int f(void)<br />
{<br />
    void *stuff = malloc(1000);</p>
<p>    if (!try_something())<br />
    {<br />
        result = -1;<br />
        goto cleanup;<br />
    }</p>
<p>    result = do_other_stuff();</p>
<p>cleanup:<br />
    free(stuff);<br />
    return result;<br />
}[/sourcecode]</p>
<p style="text-align:justify;">This occurs in svnindex, in code I copied from other parts of Subversion (in fact there is a helpful comment there, saying as much). Subversion has an exception framework in which the return value of a function is an exception (or NULL if no exception is thrown). But being C, it's also the case that memory allocated for exceptions must be manually freed. In this piece of code an exception is thrown and handled in preceding lines; the cleanup code simply clears that previous exception before returning the final exception result of the function.</p>
<p style="text-align:justify;">Jumping to cleanup code is a classic permitted use of goto in C. In this case it is a little more complicated because of the exception logic, but basically it's just freeing some memory that was allocated earlier in the function.</p>
<h3>Retrying an operation</h3>
<p style="text-align:justify;">The majority of my gotos are in this form:</p>
<p>[sourcecode language="c"]int f(void)<br />
{<br />
    int rv;<br />
restart:<br />
    rv = do_something();<br />
    if (specific_unusual_condition)<br />
    {<br />
        goto restart;<br />
    }<br />
    return rv;<br />
}[/sourcecode]</p>
<p style="text-align:justify;">I use this form when the operation in question is something that almost always succeeds the first time, but occasionally something arises part way through that means we need to start again. Structured programming purists would probably insist on replacing it with a while loop:</p>
<p>[sourcecode language="c"]int f(void)<br />
{<br />
    int rv;<br />
    int successful = 0;<br />
    while (!successful)<br />
    {<br />
        successful = 1;<br />
        rv = do_something();<br />
        if (specific_unusual_condition)<br />
        {<br />
            successful = 0;<br />
            continue;<br />
        }<br />
    }<br />
    return rv;<br />
}[/sourcecode]</p>
<p style="text-align:justify;">But, not only is that harder to read, it obscures the qualitative fact that, normally, we expect the loop to run exactly once. It also requires an extra variable because the structure forces the head of the while loop to have two possible roles in the flow control. An alternative is a do-while loop:</p>
<p>[sourcecode language="c"]int f(void)<br />
{<br />
    int rv;<br />
    do<br />
    {<br />
        rv = do_something();<br />
        if (specific_unusual_condition)<br />
        {<br />
            continue;<br />
        }<br />
    }<br />
    while (0);<br />
    return rv;<br />
}[/sourcecode]</p>
<p style="text-align:justify;">Which removes the variable. But the structure is identical to the goto implementation. The only difference is that we use the head of the loop as the label, and the word "continue" instead of "goto". The loop's test is vacuous and required only by the syntax.</p>
<h3>A dubious case</h3>
<p style="text-align:justify;">Finally, there is one instance of goto in my compiler where it is used somewhat differently. There is a part of the compiler that emits an arbitrary control-flow-graph as a linear sequence of instructions. It has a loop like this:</p>
<p>[sourcecode language="c"]while (!all_done)<br />
{<br />
    vertex = pop_vertex();<br />
    if (done(vertex))<br />
    {<br />
        continue;<br />
    }</p>
<p>do_next:<br />
    emit(vertex);<br />
    done(vertex);</p>
<p>    if (!next_vertex or done(next_vertex))<br />
    {<br />
        continue;<br />
    }<br />
    else<br />
    {<br />
        vertex = next_vertex;<br />
        goto do_next;<br />
    }<br />
}[/sourcecode]</p>
<p style="text-align:justify;">(It is only coincidence that the data the program operates on is also program code that whose structure is undergoing transformation. The general problem is that of a directed graph being listed in an efficient format, where edges are inferred to exist between subsequent nodes unless indicated otherwise.)</p>
<p style="text-align:justify;">The loop effectively has two heads: one for the case where the next instruction follows immediately on from its predecessor, and one for when a new subsequence of instructions begins. Depending on the instruction emitted, the loop with either goto the do_next label for an immediately following instruction, or will continue to the top of the while statement for a new sequence.</p>
<p style="text-align:justify;">I suspect in this case that the goto is unnecessary, and that it should be rewritten as a nested while loop.</p>
<p style="text-align:justify;">However, the algorithm is inherently complicated. It is still necessary to understand all possible cases of how a vertex related to its successors, and cover them appropriately. There have been <a title="Compiler output misses labels after tests in EJRH issues list" href="http://code.google.com/p/ejrh/issues/detail?id=9">bugs</a> in this bit of code where that wasn't the case! Regardless of while loops, it is spagehetti-like code and should be rewritten.</p>
<h2>A question on compilation</h2>
<p style="text-align:justify;">There is a well-known theorem in structured programming: any occurrence of goto in a program can be rewritten to use structured flow control with the addition of a finite number of boolean variables. The rewritten "restart" loop shown above provides an example of that.</p>
<p style="text-align:justify;">Conversely, some structured programs <em>should</em> be able to be rewritten using gotos, with the elimination of a boolean variable.</p>
<p style="text-align:justify;">If I was going to rewrite my restart loops as while loops, I wondered if the compiler would be able to optimise away the extra control variable.  Doing so could reduce register pressure, let more important variables remain in registers, and result in a faster program.  Take this bit of test code:</p>
<p>[sourcecode language="c"]extern int check();</p>
<p>extern int work();</p>
<p>void goto_test1(void)<br />
{<br />
restart:<br />
    if (check())<br />
        goto restart;</p>
<p>    work();<br />
}</p>
<p>void goto_test2(void)<br />
{<br />
    int successful = 0;<br />
    while (!successful)<br />
    {<br />
        successful = 1;<br />
        if (check())<br />
        {<br />
            successful = 0;<br />
            continue;<br />
        }<br />
    }</p>
<p>    work();<br />
}[/sourcecode]</p>
<p style="text-align:justify;">In gcc with no optimisation, the functions are compiled as:</p>
<p>[sourcecode language="c"]_goto_test1:<br />
        pushl   %ebp<br />
        movl    %esp, %ebp<br />
        subl    $8, %esp<br />
        jmp     L2<br />
L4:<br />
        nop<br />
L2:<br />
        call    _check<br />
        testl   %eax, %eax<br />
        jne     L4<br />
L3:<br />
        call    _work<br />
        leave<br />
        ret</p>
<p>_goto_test2:<br />
        pushl   %ebp<br />
        movl    %esp, %ebp<br />
        subl    $24, %esp<br />
        movl    $0, -12(%ebp)<br />
        jmp     L6<br />
L7:<br />
        movl    $1, -12(%ebp)<br />
        call    _check<br />
        testl   %eax, %eax<br />
        je      L6<br />
        movl    $0, -12(%ebp)<br />
        nop<br />
L6:<br />
        cmpl    $0, -12(%ebp)<br />
        je      L7<br />
        call    _work<br />
        leave<br />
        ret[/sourcecode]</p>
<p style="text-align:justify;">The second, properly structured function spends instructions on setting and checking that control variable. But, with even a low level of optimisation (<code>-O1</code>), the output is:</p>
<p>[sourcecode language="c"]_goto_test1:<br />
L2:<br />
        pushl   %ebp<br />
        movl    %esp, %ebp<br />
        subl    $8, %esp<br />
L3:<br />
        call    _check<br />
        testl   %eax, %eax<br />
        jne     L3<br />
        call    _work<br />
        leave<br />
        ret</p>
<p>_goto_test2:<br />
        pushl   %ebp<br />
        movl    %esp, %ebp<br />
        subl    $8, %esp<br />
L6:<br />
        call    _check<br />
        testl   %eax, %eax<br />
        jne     L6<br />
        call    _work<br />
        leave<br />
        ret<br />
[/sourcecode]</p>
<p style="text-align:justify;">The compiler is smart enough to tell that the value of the variable depends entirely on the path taken through the program, and when the structure is rewritten, the variable is superfluous.  It is optimised out.</p>
<p style="text-align:justify;">This demonstrates that concern about extra boolean variables, at least, is not an excuse for using gotos.</p>
